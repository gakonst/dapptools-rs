use clap::{Parser, ValueHint};
use ethers_contract_abigen::{
    Abigen, ContractFilter, ExcludeContracts, MultiAbigen, SelectContracts,
};
use eyre::{Result, WrapErr};
use foundry_cli::{opts::CoreBuildArgs, utils::LoadConfig};
use foundry_common::{compile::ProjectCompiler, fs::json_files};
use foundry_config::impl_figment_convert;
use std::{
    fs,
    path::{Path, PathBuf},
};
impl_figment_convert!(BindArgs, build_args);

const DEFAULT_CRATE_NAME: &str = "foundry-contracts";
const DEFAULT_CRATE_VERSION: &str = "0.1.0";

/// CLI arguments for `forge bind`.
#[derive(Clone, Debug, Parser)]
pub struct BindArgs {
    /// Path to where the contract artifacts are stored.
    #[arg(
        long = "bindings-path",
        short,
        value_hint = ValueHint::DirPath,
        value_name = "PATH"
    )]
    pub bindings: Option<PathBuf>,

    /// Create bindings only for contracts whose names match the specified filter(s)
    #[arg(long)]
    pub select: Vec<regex::Regex>,

    /// Create bindings only for contracts whose names do not match the specified filter(s)
    #[arg(long, conflicts_with = "select")]
    pub skip: Vec<regex::Regex>,

    /// Explicitly generate bindings for all contracts
    ///
    /// By default all contracts ending with `Test` or `Script` are excluded.
    #[arg(long, conflicts_with_all = &["select", "skip"])]
    pub select_all: bool,

    /// The name of the Rust crate to generate.
    ///
    /// This should be a valid crates.io crate name,
    /// however, this is not currently validated by this command.
    #[arg(long, default_value = DEFAULT_CRATE_NAME, value_name = "NAME")]
    crate_name: String,

    /// The version of the Rust crate to generate.
    ///
    /// This should be a standard semver version string,
    /// however, this is not currently validated by this command.
    #[arg(long, default_value = DEFAULT_CRATE_VERSION, value_name = "VERSION")]
    crate_version: String,

    /// Generate the bindings as a module instead of a crate.
    #[arg(long)]
    module: bool,

    /// Overwrite existing generated bindings.
    ///
    /// By default, the command will check that the bindings are correct, and then exit. If
    /// --overwrite is passed, it will instead delete and overwrite the bindings.
    #[arg(long)]
    overwrite: bool,

    /// Generate bindings as a single file.
    #[arg(long)]
    single_file: bool,

    /// Skip Cargo.toml consistency checks.
    #[arg(long)]
    skip_cargo_toml: bool,

    /// Skips running forge build before generating binding
    #[arg(long)]
    skip_build: bool,

    /// Don't add any additional derives to generated bindings
    #[arg(long)]
    skip_extra_derives: bool,

    #[command(flatten)]
    build_args: CoreBuildArgs,

    /// The description of the Rust crate to generate.
    #[clap(long, value_name = "DESCRIPTION")]
    crate_description: Option<String>,

    /// The license of the Rust crate to generate.
    #[clap(long, value_name = "LICENSE")]
    crate_license: Option<String>,
}

impl BindArgs {
    pub fn run(self) -> Result<()> {
        if !self.skip_build {
            // run `forge build`
            let project = self.build_args.project()?;
            let _ = ProjectCompiler::new().compile(&project)?;
        }

        let artifacts = self.try_load_config_emit_warnings()?.out;

        if !self.overwrite && self.bindings_exist(&artifacts) {
            println!("Bindings found. Checking for consistency.");
            return self.check_existing_bindings(&artifacts);
        }

        if self.overwrite && self.bindings_exist(&artifacts) {
            trace!(?artifacts, "Removing existing bindings");
            fs::remove_dir_all(self.bindings_root(&artifacts))?;
        }

        self.generate_bindings(&artifacts)?;

        println!(
            "Bindings have been output to {}",
            self.bindings_root(&artifacts).to_str().unwrap()
        );
        Ok(())
    }

    /// Get the path to the root of the autogenerated crate
    fn bindings_root(&self, artifacts: impl AsRef<Path>) -> PathBuf {
        self.bindings.clone().unwrap_or_else(|| artifacts.as_ref().join("bindings"))
    }

    /// `true` if the bindings root already exists
    fn bindings_exist(&self, artifacts: impl AsRef<Path>) -> bool {
        self.bindings_root(artifacts).is_dir()
    }

    /// Returns the filter to use for `MultiAbigen`
    fn get_filter(&self) -> ContractFilter {
        if self.select_all {
            return ContractFilter::All;
        }
        if !self.select.is_empty() {
            return SelectContracts::default().extend_regex(self.select.clone()).into();
        }
        if !self.skip.is_empty() {
            return ExcludeContracts::default().extend_regex(self.skip.clone()).into();
        }
        // This excludes all Test/Script and forge-std contracts
        ExcludeContracts::default()
            .extend_pattern([
                ".*Test.*",
                ".*Script",
                "console[2]?",
                "CommonBase",
                "Components",
                "[Ss]td(Chains|Math|Error|Json|Utils|Cheats|Style|Invariant|Assertions|Toml|Storage(Safe)?)",
                "[Vv]m.*",
            ])
            .extend_names(["IMulticall3"])
            .into()
    }

    /// Instantiate the multi-abigen
    fn get_multi(&self, artifacts: impl AsRef<Path>) -> Result<MultiAbigen> {
        let abigens = json_files(artifacts.as_ref())
            .into_iter()
            .filter_map(|path| {
                if path.to_string_lossy().contains("/build-info/") {
                    // ignore the build info json
                    return None
                }
                // we don't want `.metadata.json files
                let stem = path.file_stem()?;
                if stem.to_str()?.ends_with(".metadata") {
                    None
                } else {
                    Some(path)
                }
            })
            .map(|path| {
                trace!(?path, "parsing Abigen from file");
                let abi = Abigen::from_file(&path)
                    .wrap_err_with(|| format!("failed to parse Abigen from file: {:?}", path));
                if !self.skip_extra_derives {
                    abi?.add_derive("serde::Serialize")?.add_derive("serde::Deserialize")
                } else {
                    abi
                }
            })
            .collect::<Result<Vec<_>, _>>()?;
        let multi = MultiAbigen::from_abigens(abigens).with_filter(self.get_filter());

        eyre::ensure!(
            !multi.is_empty(),
            r#"
No contract artifacts found. Hint: Have you built your contracts yet? `forge bind` does not currently invoke `forge build`, although this is planned for future versions.
            "#
        );
        Ok(multi)
    }

    /// Check that the existing bindings match the expected abigen output
    fn check_existing_bindings(&self, artifacts: impl AsRef<Path>) -> Result<()> {
        let bindings = self.get_multi(&artifacts)?.build()?;
        println!("Checking bindings for {} contracts.", bindings.len());
        if !self.module {
            bindings
                .ensure_consistent_crate(
                    &self.crate_name,
                    &self.crate_version,
                    self.bindings_root(&artifacts),
                    self.single_file,
                    !self.skip_cargo_toml,
                )
                .map_err(|err| {
                    if !self.skip_cargo_toml && err.to_string().contains("Cargo.toml") {
                        err.wrap_err("To skip Cargo.toml consistency check, pass --skip-cargo-toml")
                    } else {
                        err
                    }
                })?;
        } else {
            bindings.ensure_consistent_module(self.bindings_root(&artifacts), self.single_file)?;
        }
        println!("OK.");
        Ok(())
    }

    /// Generate the bindings
    fn generate_bindings(&self, artifacts: impl AsRef<Path>) -> Result<()> {
        let mut bindings = self.get_multi(&artifacts)?.build()?;
        println!("Generating bindings for {} contracts", bindings.len());

        let bindings_root_path = self.bindings_root(&artifacts);

        if !self.module {
            trace!(single_file = self.single_file, "generating crate");
            if !self.skip_extra_derives {
                bindings = bindings.dependencies([r#"serde = "1""#])
            }
            bindings.write_to_crate(
                &self.crate_name,
                &self.crate_version,
                &bindings_root_path,
                self.single_file,
            )?;

            self.update_cargo_toml(bindings_root_path.as_path())?;
        } else {
            trace!(single_file = self.single_file, "generating module");
            bindings.write_to_module(&bindings_root_path, self.single_file)?;
        }

        Ok(())
    }

    fn update_cargo_toml(&self, bindings_root_path: &Path) -> Result<()> {
        let cargo_toml_path = bindings_root_path.join("Cargo.toml");
        let mut cargo_toml_content =
            std::fs::read_to_string(&cargo_toml_path).wrap_err("Failed to read Cargo.toml")?;

        // First try finding 'rust-version', if not found, then look for 'rust-version.workspace'
        let rust_version_pos = cargo_toml_content
            .find(r#"rust-version"#)
            .or_else(|| cargo_toml_content.find("rust-version.workspace"));

        if let Some(pos) = rust_version_pos {
            // Find the end of the line
            let insert_point =
                cargo_toml_content[pos..].find('\n').unwrap_or(cargo_toml_content.len()) + pos;
            let mut insert_content = String::new();

            // Check and append description
            if let Some(description) = &self.crate_description {
                insert_content.push_str(&format!("\ndescription = {:?}", description));
            }

            // Check and append license
            if let Some(license) = &self.crate_license {
                insert_content.push_str(&format!("\nlicense = {:?}", license));
            }

            cargo_toml_content.insert_str(insert_point, &insert_content);
        } else {
            // Handle the case where neither 'rust-version' nor 'rust-version.workspace' is found
            return Err(eyre::eyre!(
                "Neither 'rust-version' nor 'rust-version.workspace' found in Cargo.toml"
            ));
        }

        std::fs::write(&cargo_toml_path, cargo_toml_content)
            .wrap_err("Failed to write updated Cargo.toml")?;

        Ok(())
    }
}
